#!/usr/bin/env python
# coding=utf-8
import os
import re

from androguard.core.analysis.analysis import Analysis
# 混淆的应用不会将Manifest混淆
from androguard.core.bytecodes.apk import APK
from androguard.core.bytecodes.dvm import DalvikVMFormat
import androguard

useless_api = ["<init>", "toString", "hashCode",
               "get", "put", "equals", "set", "size", "init", "toArray", "clone",
               "length", "start", "isEmpty", "add", "getInstance", "append",
               "close", "valueOf", "setVisibility", "setText"]


# log信息
def log(message, file_path=os.path.join('feature_log', 'log.txt')):
    print(message)
    f1 = open(file_path, 'a+')
    f1.write(message)
    f1.close()


def get_permissions(path):
    """
    Get the permissions from an app.
    Parameters:
      path - The path of the app to be decompiled
    Returns:
      A sorted list of permissions
    """
    app = APK(path)
    perms = app.get_permissions()
    # 去重并排序
    perms = list(set(perms))
    perms.sort()
    return perms


def get_apis(path):
    error_file = open("../error_files.txt", "w")

    """
    Get the APIs from an application.
    Parameters:
      path - The path of the application to be decompiled
    Returns:
      A sorted list of APIs with parameters
    """
    try:
        # You can see the documents of androguard to get the further details
        # of the decompilation procedures.
        # 获取APK文件对象
        # application:表示APK对象，在其中可以找到有关 APK 的信息，例如包名、权限、AndroidManifest.xml、resources
        # application_dex:DalvikVMFormat 对象数组，DalvikVMFormat 对应 apk 文件中的 dex 文件，从 dex 文件中我们可以获取类、方法和字符串。
        # application_x：表示 Analysis 对象，其包含链接了关于 classes.dex 信息的特殊的类，甚至可以一次处理许多 dex 文件。
        application = APK(path)
        application_dex = DalvikVMFormat(application.get_dex())
        application_x = Analysis(application_dex)

        methods = set()
        # 获得class 对象
        classesList = [classes.get_name() for classes in application_dex.get_classes()]
        # print("classesList:", classesList)
        # 获得methods方法
        for method in application_dex.get_methods():
            methodAnalysis = application_x.get_method(method)
            if method.get_code() is None:
                continue

            for basicBlocks in methodAnalysis.get_basic_blocks().get():
                # 获得jvm指令
                for instructions in basicBlocks.get_instructions():
                    #  这是一个包含方法，变量或其他任何内容的字符串
                    output = instructions.get_output()
                    # print("output", output)

                    # Here we use regular expression to check if it is a function
                    # call. A function call comprises four parts: a class name, a
                    # function name, zero or more parameters, and a return type.
                    # The pattern is actually simple:
                    #
                    #      CLASS NAME: starts with a character L and ends in a right
                    #                  arrow.
                    #   FUNCTION NAME: starts with the right arrow and ends in a
                    #                  left parenthesis.
                    #      PARAMETERS: are between the parentheses.
                    #     RETURN TYPE: is the rest of the string.
                    #
                    # 这里拿到的classList是应用本身的类，第二个匹配的组（一个括号一个组）是调用的类不是应用本身的类，是系统的类
                    # 这里就是通过系统接口调用来做判断。
                    match = re.search(r'(L[^;]*;)->[^\(]*\([^\)]*\).*', output)
                    # print("----")
                    # if match:
                    #     log(match.group() + "----" + match.group(1), "->" + (match.group(1) not in classesList))
                    # print(match.group() + "----" + match.group(1), "->", (match.group(1) not in classesList))
                    # print("isInClassList:", match.group(1), "->", (match.group(1) not in classesList))

                    # match.group():Landroid/app/IntentService;-><init>(Ljava/lang/String;)V
                    # match.group(1):Landroid/app/IntentService;
                    if match and match.group(1) not in classesList:
                        # print(match.group() + "----" + match.group(1))
                        methods.add(match.group())
        methods = list(methods)

    except Exception as e:
        print(e)
        print("path", path)
        error_file.write(path)

    return methods


# APIS 提纯
def refine_apis(apis):
    api_list = []
    for api in apis:
        tempApi = api
        start_index = api.find('>')
        end_index = api.find('(')
        start_index += 1
        if (len(api[start_index:end_index]) > 1) & (api[start_index:end_index] not in useless_api):
            api = api[start_index:end_index] + '()'
            # api:read()
            # api: getActivity()
            # 这里精简了api，只拿到方法名称
            # print("api:" + api)
            api_list.append(api)
        # print("tempApi:" + tempApi + ",api:" + api)

    return api_list


# 搜集全部的permission
def collect_permissions_3rgs(global_permissions, permissions, permissions_dict):
    global_permissions.append(permissions)
    for p in permissions:
        if p in permissions_dict:
            permissions_dict[str(p)] += 1
        else:
            permissions_dict[str(p)] = 1


def collect_permissions(perms, permissions_dict):
    for p in perms:
        if p in permissions_dict:
            permissions_dict[str(p)] += 1
        else:
            permissions_dict[str(p)] = 1


def collect_apis_3rgs(global_apis, apis, apis_dict):
    ref_apis = refine_apis(apis)
    global_apis.append(ref_apis)
    # print("global_apis", global_apis)
    for api in ref_apis:
        if api in apis_dict:
            apis_dict[str(api)] += 1
        else:
            apis_dict[str(api)] = 1


def collect_apis(apis, apis_dict):
    ref_apis = refine_apis(apis)
    for api in ref_apis:
        if api in apis_dict:
            apis_dict[str(api)] += 1
        else:
            apis_dict[str(api)] = 1


def main():
    """
    For test
    """
    path = "MiTVOtService.apk"

    print(get_permissions(path))
    result = get_apis(path)

    for result in result:
        print("result:", result)
        start_index = result.find('>')
        end_index = result.find('(')
        start_index += 1
        result = result[start_index:end_index]
        print(result)


if __name__ == '__main__':
    main()
